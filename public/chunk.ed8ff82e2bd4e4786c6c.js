/*! For license information please see chunk.ed8ff82e2bd4e4786c6c.js.LICENSE.txt */
"use strict";(self.webpackChunkai_workout_assistant=self.webpackChunkai_workout_assistant||[]).push([[306],{69869:(e,t,n)=>{n.d(t,{e:()=>s});var r=n(20569);function s(e,t,n,s,a,i){null==s&&(s=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=e.shape[0];return n=Math.min(n,o),r.hu(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`)),r.hu(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),r.hu(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),r.hu(1===t.rank,(()=>"scores must be a 1D tensor")),r.hu(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),r.hu(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:s,scoreThreshold:a,softNmsSigma:i}}},3561:(e,t,n)=>{n.d(t,{K:()=>b});var r=n(43740),s=n(20569),a=n(96235),i=n(83591),o=n(83307),l=n(25735),u=n(2668),h=n(33453),c=n(4968),d=n(99494),p=n(13261),f=n(50248),m=n(15475);function g(e,t,n=null){if(0===e.rank)return(0,a.W)(e);if(1!==e.rank&&null===n)return g((0,c.X)(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.S)((0,a.W)(e),n);if(t===1/0)return(0,o.F)((0,a.W)(e),n);if(t===-1/0)return(0,l.V)((0,a.W)(e),n);if("euclidean"===t||2===t)return(0,p._)((0,m.S)((0,h.s)((0,a.W)(e),(0,d.i)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,o.F)((0,m.S)((0,a.W)(e),n[0]),n[1]-1);if(t===1/0)return(0,o.F)((0,m.S)((0,a.W)(e),n[1]),n[0]);if(t===-1/0)return(0,l.V)((0,m.S)((0,a.W)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p._)((0,m.S)((0,f.h)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const b=(0,u.op)({norm_:function(e,t="euclidean",n=null,a=!1){const o=g(e=(0,r._1)(e,"x","norm"),t,n);let l=o.shape;if(a){const t=(0,s.EC)(n,e.shape);l=i.rv(o.shape,t)}return(0,c.X)(o,l)}})},16500:(e,t,n)=>{n.d(t,{Q:()=>l});var r=n(23926),s=n(29121),a=n(80747),i=n(43740),o=n(72200);const l=(0,n(2668).op)({notEqual_:function(e,t){let n=(0,i._1)(e,"a","notEqual","string_or_numeric"),l=(0,i._1)(t,"b","notEqual","string_or_numeric");[n,l]=(0,a.T_)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.BV.runKernel(s.yQU,u)}})},44917:(e,t,n)=>{n.d(t,{i:()=>o});var r=n(23926),s=n(20569),a=n(61661),i=n(59640);function o(e,t="float32"){if((0,s.Mu)(e),"complex64"===t){const t=o(e,"float32"),n=(0,i.l)(e,"float32");return(0,a.P)(t,n)}const n=(0,s.p8)((0,s.NA)(e),t);return r.BV.makeTensor(n,e,t)}},2668:(e,t,n)=>{n.d(t,{op:()=>i,z:()=>a});var r=n(23926),s=n(20569);const a="__op";function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=a;const o=(...e)=>{r.BV.startScope(n);try{const t=i(...e);return(0,s.tI)(t)&&console.error("Cannot return a Promise inside of tidy."),r.BV.endScope(t),t}catch(e){throw r.BV.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},15863:(e,t,n)=>{n.d(t,{zvA:()=>rt.z,WnP:()=>r.W,Khb:()=>s.K,__u:()=>a._,IHx:()=>i.I,QBD:()=>o.Q,$6P:()=>l.$,YjB:()=>u.Y,NqF:()=>h.N,vHJ:()=>c.v,ZRM:()=>d.Z,VfV:()=>p.V,z4N:()=>f.z,fvJ:()=>m.f,C80:()=>g.C,wS1:()=>b.w,uR5:()=>y.u,zEQ:()=>w.z,tgs:()=>_.t,Dxk:()=>$.D,JY5:()=>S.J,p3b:()=>k.p,E4h:()=>v.E,yE8:()=>x.y,anm:()=>Fn.a,XsQ:()=>E.X,UFq:()=>A.U,f3b:()=>T.f,pju:()=>I.p,mDi:()=>N.m,iUl:()=>M.i,d9v:()=>V.d,PYB:()=>B.P,zoF:()=>R.z,gME:()=>D.g,Izb:()=>G.I,MNy:()=>C.M,ZaL:()=>P.Z,PAt:()=>W.P,Tek:()=>O.T,bc:()=>q.b,pdZ:()=>z.p,$QV:()=>F.$,mCk:()=>K.m,f9Y:()=>U.f,mew:()=>Jn,$Gn:()=>L.$,zbp:()=>j.z,ppE:()=>H.p,nTT:()=>X.n,B10:()=>Q.B,Ka3:()=>Y.K,WmZ:()=>Z.W,hiC:()=>J.h,NTj:()=>ee.N,AKD:()=>te.A,rvX:()=>Yn.r,WYO:()=>ne.W,pyx:()=>re.p,GRh:()=>Zn,DgJ:()=>se.D,qNN:()=>ae.q,d2q:()=>ie.d,Qqt:()=>oe.Q,dt4:()=>le.d,t$B:()=>ue.t,iyy:()=>he.i,kp_:()=>an,hlL:()=>ce.h,GWj:()=>de.G,qPi:()=>pe.q,imm:()=>tr,Iqj:()=>fe.I,dbB:()=>Qn.d,pjt:()=>me.p,brS:()=>ge.b,Sxn:()=>on,asL:()=>be.a,BHj:()=>qr,V3u:()=>er.V,wx0:()=>ln,xVT:()=>ye.x,UWc:()=>we.U,i2d:()=>ve.i,hi7:()=>_e.h,d9m:()=>$e.d,zN1:()=>Se.z,$r2:()=>zr,SX3:()=>ke.S,G9k:()=>xe.G,cM7:()=>Ee.c,Krr:()=>Ae.K,e_t:()=>Te.e,CmS:()=>Ie.C,l_t:()=>Ne.l,HvI:()=>Me.H,hJK:()=>Ve.h,K5V:()=>Be.K,egP:()=>Re.e,MB5:()=>Fr,eab:()=>De.e,OI3:()=>Ge.O,Fp7:()=>Ce.F,_sB:()=>Pe._,YQQ:()=>We.Y,Ip$:()=>Oe.I,gWQ:()=>qe.g,J69:()=>ze.J,ry_:()=>Fe.r,VV$:()=>Ke.V,LTh:()=>Ue.L,VdP:()=>Le.V,wQq:()=>je.w,Gi7:()=>He.G,p_:()=>Ln.p,dC7:()=>Xe.d,rq4:()=>Qe.r,SJ_:()=>Ye.S,W76:()=>Ze.W,KOy:()=>Un.K,Quu:()=>Je.Q,lfX:()=>st,iUs:()=>at.i,JpU:()=>it,op:()=>rt.op,N2O:()=>ut,vku:()=>ht.v,pNR:()=>ct,koy:()=>dt,t1L:()=>pt,lGY:()=>ft,d_R:()=>bt,sQ3:()=>yt.s,AL3:()=>wt.A,S0v:()=>vt.S,WVs:()=>_t,$gW:()=>$t,VT$:()=>St,N89:()=>kt,TN_:()=>xt,wzB:()=>At,nGf:()=>Tt,ruB:()=>It,LGj:()=>Nt.L,w6H:()=>Mt.w,kwC:()=>Vt.k,M25:()=>Bt,UYe:()=>Rt.U,btT:()=>Dt.b,XLQ:()=>lt.X,GYS:()=>Gt.G,SDf:()=>Ct,diP:()=>Pt,sx7:()=>Wt,mG2:()=>Ot,QEs:()=>dn,NMM:()=>qt.N,bp0:()=>zt.b,iD$:()=>Ft.i,snQ:()=>Hn,zcT:()=>Pn.z,U8D:()=>Kt,U_I:()=>Ut,ODp:()=>jt,XD2:()=>Ht.X,Xxe:()=>Xt,tdS:()=>Or,O$l:()=>Qt.O,R_K:()=>Yt.R,tPi:()=>Zt.t,jZU:()=>Jt,SmN:()=>en,CnO:()=>tn,p0P:()=>nn,XAC:()=>rn,Wvh:()=>sn.W,fBT:()=>gt.f,rVs:()=>Kr,ers:()=>Xn,uN7:()=>Wr,Vl2:()=>un.V,_b3:()=>pn._,h62:()=>fn.h,$i:()=>mn.$,L9e:()=>gn.L,knu:()=>bn.k,Nbs:()=>yn.N,NXj:()=>wn,Z_8:()=>Ur,luU:()=>vn.l,Smz:()=>_n.S,ORZ:()=>$n,AEp:()=>Sn.A,XeE:()=>kn.X,RRF:()=>xn.R,odF:()=>En.o,wOQ:()=>An.w,yXz:()=>In,Bfx:()=>Nn,xZs:()=>Mn,Gg6:()=>Vn.G,hg7:()=>Bn,p4s:()=>Kn.p,Xu6:()=>Rn,Two:()=>Dn,pUJ:()=>Gn.p,HHK:()=>Cn.H,GaM:()=>Wn,VD$:()=>On,arb:()=>qn.a,itS:()=>zn.i,lls:()=>hn.l,P84:()=>cn.P});var r=n(96235),s=n(17839),a=n(91470),i=n(56407),o=n(13135),l=n(90781),u=n(92998),h=n(40047),c=n(27394),d=n(72421),p=n(21891),f=n(77037),m=n(29812),g=n(80369),b=n(15176),y=n(61749),w=n(7361),v=n(28441),_=n(27505),$=n(81837),S=n(319),k=n(37969),x=n(93865),E=n(88194),A=n(68247),T=n(72657),I=n(62271),N=n(6825),M=n(42279),V=n(8723),B=n(61661),R=n(46884),D=n(72248),G=n(99373),C=n(8093),P=n(64435),W=n(11355),O=n(64794),q=n(71405),z=n(70473),F=n(11160),K=n(70173),U=n(2699),L=n(9640),j=n(37405),H=n(75746),X=n(89112),Q=n(64718),Y=n(31118),Z=n(70557),J=n(41274),ee=n(49322),te=n(30548),ne=n(94653),re=n(83233),se=n(26477),ae=n(34650),ie=n(31954),oe=n(44842),le=n(81300),ue=n(53426),he=n(66557),ce=n(14006),de=n(26943),pe=n(9165),fe=n(24926),me=n(20636),ge=n(17630),be=n(64386),ye=n(13963),we=n(4365),ve=n(96230),_e=n(99133),$e=n(86573),Se=n(50624),ke=n(14135),xe=n(79648),Ee=n(82597),Ae=n(17474),Te=n(13888),Ie=n(31510),Ne=n(11391),Me=n(2856),Ve=n(38651),Be=n(15750),Re=n(10596),De=n(94608),Ge=n(28687),Ce=n(83307),Pe=n(21174),We=n(25020),Oe=n(96877),qe=n(80632),ze=n(75130),Fe=n(82541),Ke=n(25735),Ue=n(24513),Le=n(71483),je=n(85228),He=n(73276),Xe=n(24841),Qe=n(78656),Ye=n(90686),Ze=n(17370),Je=n(16500),et=n(23926),tt=n(29121),nt=n(43740),rt=n(2668);const st=(0,rt.op)({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:(0,nt._1)(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return et.BV.runKernel(tt.we_,a,i)}});var at=n(44917);const it=(0,rt.op)({onesLike_:function(e){const t={x:(0,nt._1)(e,"x","onesLike")};return et.BV.runKernel(tt.qWM,t)}});var ot=n(20569),lt=n(4968);const ut=(0,rt.op)({outerProduct_:function(e,t){const n=(0,nt._1)(e,"v1","outerProduct"),r=(0,nt._1)(t,"v2","outerProduct");ot.hu(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=(0,lt.X)(n,[-1,1]),a=(0,lt.X)(r,[1,-1]);return(0,Ge.O)(s,a)}});var ht=n(39682);const ct=(0,rt.op)({pad1d_:function(e,t,n=0){return(0,ot.hu)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,ht.v)(e,[t],n)}}),dt=(0,rt.op)({pad2d_:function(e,t,n=0){return(0,ot.hu)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ht.v)(e,t,n)}}),pt=(0,rt.op)({pad3d_:function(e,t,n=0){return(0,ot.hu)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ht.v)(e,t,n)}}),ft=(0,rt.op)({pad4d_:function(e,t,n=0){return(0,ot.hu)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,ht.v)(e,t,n)}});var mt=n(2582),gt=n(27918);const bt=(0,rt.op)({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=(0,nt._1)(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=(0,lt.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ot.hu(mt.jT(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const h=mt.Xw(l.shape,t,a,s,r),c=[h.dilationHeight,h.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([h.filterHeight,h.filterWidth],c):[[0,0],[0,0]];const p=1===c[0]&&1===c[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t]));return[t.map(((e,t)=>[r[t],o[t]])),t.map(((e,t)=>[0,i[t]]))]}([h.inHeight,h.inWidth],c,d),g=p?r:"valid",y=p?l:(0,gt.f)(l,c,f),w=("avg"===n?()=>(0,b.w)(y,t,a,g,i):()=>(0,Pe._)(y,t,a,g,i))(),_=p?w:(0,v.E)(w,c,m);return u?(0,lt.X)(_,[_.shape[1],_.shape[2],_.shape[3]]):_}});var yt=n(33453),wt=n(98151),vt=n(29798);const _t=(0,rt.op)({prod_:function(e,t=null,n=!1){let r=(0,nt._1)(e,"x","prod");"bool"===r.dtype&&(r=(0,I.p)(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return et.BV.runKernel(tt.DlI,s,a)}}),$t=(0,rt.op)({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>(0,nt._1)(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:(0,nt._1)(t,"paramsDenseValues","raggedGather"),indices:(0,nt._1)(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=et.BV.runKernel(tt.dDz,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}}),St=(0,rt.op)({raggedRange_:function(e,t,n){const r=(0,nt._1)(e,"starts","raggedRange"),s={starts:r,limits:(0,nt._1)(t,"limits","raggedRange",r.dtype),deltas:(0,nt._1)(n,"deltas","raggedRange",r.dtype)},a=et.BV.runKernel(tt.CQl,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),kt=(0,rt.op)({raggedTensorToTensor_:function(e,t,n,r,s){const a=(0,nt._1)(e,"shape","raggedTensorToTensor","int32"),i=(0,nt._1)(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:(0,nt._1)(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>(0,nt._1)(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:s};return et.BV.runKernel(tt.BiW,o,l)}}),xt=(0,rt.op)({rand_:function(e,t,n){(0,ot.Mu)(e);const r=(0,ot.NA)(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return et.BV.makeTensor(s,e,n)}});var Et=n(56845);const At=(0,rt.op)({randomGamma_:function(e,t,n=1,r="float32",s){if((0,ot.Mu)(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new Et.T9(t,n,r,s),i=(0,T.f)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Tt=(0,rt.op)({randomNormal_:function(e,t=0,n=1,r,s){if((0,ot.Mu)(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Et.Yi(t,n,r,!1,s),i=(0,T.f)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),It=(0,rt.op)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Tt(e,0,1,t,n)}});var Nt=n(75002),Mt=n(47245),Vt=n(60766);const Bt=(0,rt.op)({reciprocal_:function(e){const t={x:(0,nt._1)(e,"x","reciprocal")};return et.BV.runKernel(tt.$HU,t)}});var Rt=n(7409),Dt=n(83582),Gt=n(57486);const Ct=(0,rt.op)({reverse1d_:function(e){const t=(0,nt._1)(e,"x","reverse");return ot.hu(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,Gt.G)(t,0)}}),Pt=(0,rt.op)({reverse2d_:function(e,t){const n=(0,nt._1)(e,"x","reverse");return ot.hu(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),(0,Gt.G)(n,t)}}),Wt=(0,rt.op)({reverse3d_:function(e,t){const n=(0,nt._1)(e,"x","reverse");return ot.hu(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),(0,Gt.G)(n,t)}}),Ot=(0,rt.op)({reverse4d_:function(e,t){const n=(0,nt._1)(e,"x","reverse");return ot.hu(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),(0,Gt.G)(n,t)}});var qt=n(97809),zt=n(32634),Ft=n(99494);const Kt=(0,rt.op)({selu_:function(e){const t={x:(0,nt._1)(e,"x","selu")};return et.BV.runKernel(tt.oFR,t)}}),Ut=(0,rt.op)({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=(0,nt._1)(e,"x","separableConv2d"),l=(0,nt._1)(t,"depthwiseFilter","separableConv2d"),u=(0,nt._1)(n,"pointwiseFilter","separableConv2d");let h=o,c=!1;if(3===o.rank&&(c=!0,h=(0,lt.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ot.hu(4===h.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`)),ot.hu(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),ot.hu(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),ot.hu(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),ot.hu(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];ot.hu(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=(0,Q.B)(h,l,r,s,i,a),m=(0,O.T)(f,u,1,"valid",i);return c?(0,lt.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var Lt=n(4077);const jt=async function(e,t){const n=(0,nt._1)(e,"x","setdiff1d"),r=(0,nt._1)(t,"y","setdiff1d");ot.hu(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),ot.hu(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ot.hu(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const l=new Lt.YD([o],n.dtype),u=new Lt.YD([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(l.values[t]=s[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};var Ht=n(30625);const Xt=(0,rt.op)({sign_:function(e){const t={x:(0,nt._1)(e,"x","sign")};return et.BV.runKernel(tt.i5y,t)}});var Qt=n(99331),Yt=n(83254),Zt=n(22676);const Jt=(0,rt.op)({slice1d_:function(e,t,n){const r=(0,nt._1)(e,"x","slice1d");return ot.hu(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,Zt.t)(r,[t],[n])}}),en=(0,rt.op)({slice2d_:function(e,t,n){const r=(0,nt._1)(e,"x","slice2d");return ot.hu(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,Zt.t)(r,t,n)}}),tn=(0,rt.op)({slice3d_:function(e,t,n){const r=(0,nt._1)(e,"x","slice3d");return ot.hu(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,Zt.t)(r,t,n)}}),nn=(0,rt.op)({slice4d_:function(e,t,n){const r=(0,nt._1)(e,"x","slice4d");return ot.hu(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,Zt.t)(r,t,n)}}),rn=(0,rt.op)({softmax_:function(e,t=-1){const n=(0,nt._1)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return et.BV.runKernel(tt.Gcp,r,s)}});var sn=n(3694);const an=(0,rt.op)({fft_:function(e){(0,ot.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return et.BV.runKernel(tt.vwp,t)}}),on=(0,rt.op)({ifft_:function(e){(0,ot.hu)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return et.BV.runKernel(tt.Qg5,t)}}),ln=(0,rt.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=(0,lt.X)(e,[n,t]);r=on(s)}else{const s=[n,2*(t-1)],a=(0,lt.X)((0,Vt.k)(e),[n,t]),i=(0,lt.X)((0,be.a)(e),[n,t]),o=(0,Gt.G)((0,Zt.t)(a,[0,1],[n,t-2]),1),l=(0,Xe.d)((0,Gt.G)((0,Zt.t)(i,[0,1],[n,t-2]),1),(0,Ft.i)(-1)),u=(0,R.z)([a,o],1),h=(0,R.z)([i,l],1),c=(0,lt.X)((0,B.P)(u,h),[s[0],s[1]]);r=on(c)}if(r=(0,Vt.k)(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=(0,lt.X)(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});var un=n(28644),hn=n(59640),cn=n(6577);const dn=(0,rt.op)({rfft_:function(e,t){(0,ot.hu)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=(0,Zt.t)(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=(0,R.z)([e,(0,hn.l)(r)],e.shape.length-1),n=t}else s=e;const a=(0,cn.P)(s),i=(0,lt.X)((0,B.P)(s,a),[r,n]),o=an(i),l=Math.floor(n/2)+1,u=(0,Vt.k)(o),h=(0,be.a)(o),c=(0,un.V)(u,[l,n-l],u.shape.length-1),d=(0,un.V)(h,[l,n-l],h.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,(0,lt.X)((0,B.P)(c[0],d[0]),p)}});var pn=n(13261),fn=n(50248),mn=n(15265),gn=n(79590),bn=n(82991),yn=n(71901);const wn=(0,rt.op)({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:(0,nt._1)(e,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return et.BV.runKernel(tt.jQk,u,h)}});var vn=n(70827),_n=n(15475);const $n=(0,rt.op)({tan_:function(e){const t={x:(0,nt._1)(e,"x","tan","float32")};return et.BV.runKernel(tt.sEM,t)}});var Sn=n(21869),kn=n(10701),xn=n(46092),En=n(24376),An=n(99906),Tn=n(57852);function In(e,t,n){if((0,ot.Cq)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,nt.C)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Tn.H)(e,t,r,n)}function Nn(e,t,n){if((0,ot.Cq)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,nt.C)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Tn.H)(e,t,r,n)}function Mn(e,t,n){if((0,ot.Cq)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,nt.C)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,Tn.H)(e,t,r,n)}var Vn=n(47501);const Bn=(0,rt.op)({topk_:function(e,t=1,n=!0){const r=(0,nt._1)(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=et.BV.runKernel(tt.cWu,a,i);return{values:o,indices:l}}}),Rn=(0,rt.op)({truncatedNormal_:function(e,t=0,n=1,r,s){if((0,ot.Mu)(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Et.Yi(t,n,r,!0,s),i=(0,T.f)(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Dn=(0,rt.op)({unique_:function(e,t=0){const n=(0,nt._1)(e,"x","unique","string_or_numeric");(0,ot.hu)(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=et.BV.runKernel(tt.kpP,r,s);return{values:a,indices:i}}});var Gn=n(98749),Cn=n(24136),Pn=n(43336);function Wn(e,t){return(0,Pn.z)(e,t,"right")}function On(e,t=!0,n,r){return et.BV.makeVariable(e,t,n,r)}var qn=n(95912),zn=n(66380),Fn=n(5123),Kn=n(89065),Un=n(3561),Ln=n(96476),jn=n(33028);const Hn=(0,rt.op)({scatterND_:function(e,t,n){(0,ot.Mu)(n);const r=(0,nt._1)(e,"indices","scatterND","int32"),s=(0,nt._1)(t,"updates","scatterND");jn.b0(s,r,n);const a={indices:r,updates:s},i={shape:n};return et.BV.runKernel(tt.xQA,a,i)}}),Xn=(0,rt.op)({sparseToDense_:function(e,t,n,r=0){(0,ot.Mu)(n);const s=(0,nt._1)(e,"sparseIndices","sparseToDense","int32"),a=(0,nt._1)(t,"sparseValues","sparseToDense","string_or_numeric"),i=(0,nt._1)(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return et.BV.runKernel(tt.D2d,o,l)}});var Qn=n(87494),Yn=n(72223);function Zn(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Jn(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return(0,xn.R)(s,"float32")}var er=n(92166),tr=n(84624);const nr=(0,rt.op)({hammingWindow_:function(e){return Jn(e,.54,.46)}}),rr=(0,rt.op)({hannWindow_:function(e){return Jn(e,.5,.5)}}),sr=(0,rt.op)({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push((0,Zt.t)(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=(0,R.z)([(0,Zt.t)(e,a,t-r),(0,ce.h)([r],s)]);i.push(o),a+=n}return 0===i.length?(0,En.o)([],[0,t]):(0,lt.X)((0,R.z)(i),[i.length,t])}}),ar=(0,rt.op)({stft_:function(e,t,n,r,s=rr){null==r&&(r=Zn(t));const a=sr(e,t,n),i=(0,Xe.d)(a,s(t));return dn(i,r)}});var ir=n(61066),or=n(90824),lr=n(16114),ur=n(26466),hr=n(99009),cr=n(56526),dr=n(91424),pr=n(18135),fr=n(63765),mr=n(88500),gr=n(13305),br=n(95098),yr=n(92381),wr=n(81034),vr=n(601),_r=n(25453),$r=n(32512),Sr=n(41326),kr=n(36142),xr=n(77789),Er=n(29599),Ar=n(95317),Tr=n(4824),Ir=n(42695),Nr=n(75706),Mr=n(67740);const Vr=(0,rt.op)({sparseFillEmptyRows_:function(e,t,n,r){const s=(0,nt._1)(e,"indices","sparseFillEmptyRows","int32"),a=(0,nt._1)(t,"values","sparseFillEmptyRows"),i=(0,nt._1)(n,"denseShape","sparseFillEmptyRows","int32"),o=(0,nt._1)(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=et.BV.runKernel(tt.O3z,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),Br=(0,rt.op)({sparseReshape_:function(e,t,n){const r=(0,nt._1)(e,"inputIndices","sparseReshape","int32"),s=(0,nt._1)(t,"inputShape","sparseReshape","int32"),a=(0,nt._1)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=et.BV.runKernel(tt.nhH,i);return{outputIndices:o[0],outputShape:o[1]}}}),Rr=(0,rt.op)({sparseSegmentMean_:function(e,t,n){const r=(0,nt._1)(e,"data","sparseSegmentMean"),s=(0,nt._1)(t,"indices","sparseSegmentMean","int32"),a=(0,nt._1)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return et.BV.runKernel(tt.w3H,i)}}),Dr=(0,rt.op)({sparseSegmentSum_:function(e,t,n){const r=(0,nt._1)(e,"data","sparseSegmentSum"),s=(0,nt._1)(t,"indices","sparseSegmentSum","int32"),a=(0,nt._1)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return et.BV.runKernel(tt.ZjV,i)}}),Gr=(0,rt.op)({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=(0,nt._1)(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=(0,nt._1)(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},c={data:l,dataSplits:u},d=et.BV.runKernel(tt._JP,c,h);return{nGrams:d[0],nGramsSplits:d[1]}}}),Cr=(0,rt.op)({stringSplit_:function(e,t,n=!0){const r=(0,nt._1)(e,"input","stringSplit","string"),s=(0,nt._1)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=et.BV.runKernel(tt.s1s,i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),Pr=(0,rt.op)({stringToHashBucketFast_:function(e,t){const n=(0,nt._1)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return et.BV.runKernel(tt.XkS,s,r)}}),Wr={fft:an,ifft:on,rfft:dn,irfft:ln},Or={hammingWindow:nr,hannWindow:rr,frame:sr,stft:ar},qr={flipLeftRight:or.V,grayscaleToRGB:lr.F,resizeNearestNeighbor:br.j,resizeBilinear:gr.I,rotateWithOffset:ur.f,cropAndResize:ir.B,nonMaxSuppression:hr.o,nonMaxSuppressionAsync:cr.V,nonMaxSuppressionWithScore:dr.t,nonMaxSuppressionWithScoreAsync:pr.B,nonMaxSuppressionPadded:fr.q,nonMaxSuppressionPaddedAsync:mr.N,threshold:yr.L,transform:wr.v},zr={bandPart:vr.P,gramSchmidt:_r.G,qr:$r.qr},Fr={absoluteDifference:Sr.O,computeWeightedLoss:kr.m,cosineDistance:xr.Z,hingeLoss:Er.O,huberLoss:Ar.H,logLoss:Tr.g,meanSquaredError:Ir.F,sigmoidCrossEntropy:Nr.f,softmaxCrossEntropy:Mr.E},Kr={sparseFillEmptyRows:Vr,sparseReshape:Br,sparseSegmentMean:Rr,sparseSegmentSum:Dr},Ur={stringNGrams:Gr,stringSplit:Cr,stringToHashBucketFast:Pr}},97611:(e,t,n)=>{n.r(t),n.d(t,{OP_SCOPE_SUFFIX:()=>r.zvA,abs:()=>r.WnP,acos:()=>r.Khb,acosh:()=>r.__u,add:()=>r.IHx,addN:()=>r.QBD,all:()=>r.$6P,any:()=>r.YjB,argMax:()=>r.NqF,argMin:()=>r.vHJ,asin:()=>r.ZRM,asinh:()=>r.VfV,atan:()=>r.z4N,atan2:()=>r.fvJ,atanh:()=>r.C80,avgPool:()=>r.wS1,avgPool3d:()=>r.uR5,basicLSTMCell:()=>r.zEQ,batchNorm:()=>r.tgs,batchNorm2d:()=>r.Dxk,batchNorm3d:()=>r.JY5,batchNorm4d:()=>r.p3b,batchToSpaceND:()=>r.E4h,bincount:()=>r.yE8,booleanMaskAsync:()=>r.anm,broadcastArgs:()=>r.XsQ,broadcastTo:()=>r.UFq,buffer:()=>r.f3b,cast:()=>r.pju,ceil:()=>r.mDi,clipByValue:()=>r.iUl,clone:()=>r.d9v,complex:()=>r.PYB,concat:()=>r.zoF,concat1d:()=>r.gME,concat2d:()=>r.Izb,concat3d:()=>r.MNy,concat4d:()=>r.ZaL,conv1d:()=>r.PAt,conv2d:()=>r.Tek,conv2dTranspose:()=>r.bc,conv3d:()=>r.pdZ,conv3dTranspose:()=>r.$QV,cos:()=>r.mCk,cosh:()=>r.f9Y,cosineWindow:()=>r.mew,cumprod:()=>r.$Gn,cumsum:()=>r.zbp,denseBincount:()=>r.ppE,depthToSpace:()=>r.nTT,depthwiseConv2d:()=>r.B10,diag:()=>r.Ka3,dilation2d:()=>r.WmZ,div:()=>r.hiC,divNoNan:()=>r.NTj,dot:()=>r.AKD,dropout:()=>r.rvX,einsum:()=>r.WYO,elu:()=>r.pyx,enclosingPowerOfTwo:()=>r.GRh,equal:()=>r.DgJ,erf:()=>r.qNN,euclideanNorm:()=>r.d2q,exp:()=>r.Qqt,expandDims:()=>r.dt4,expm1:()=>r.t$B,eye:()=>r.iyy,fft:()=>r.kp_,fill:()=>r.hlL,floor:()=>r.GWj,floorDiv:()=>r.qPi,fused:()=>r.imm,gather:()=>r.Iqj,gatherND:()=>r.dbB,greater:()=>r.pjt,greaterEqual:()=>r.brS,ifft:()=>r.Sxn,imag:()=>r.asL,image:()=>r.BHj,inTopKAsync:()=>r.V3u,irfft:()=>r.wx0,isFinite:()=>r.xVT,isInf:()=>r.UWc,isNaN:()=>r.i2d,leakyRelu:()=>r.hi7,less:()=>r.d9m,lessEqual:()=>r.zN1,linalg:()=>r.$r2,linspace:()=>r.SX3,localResponseNormalization:()=>r.G9k,log:()=>r.cM7,log1p:()=>r.Krr,logSigmoid:()=>r.e_t,logSoftmax:()=>r.CmS,logSumExp:()=>r.l_t,logicalAnd:()=>r.HvI,logicalNot:()=>r.hJK,logicalOr:()=>r.K5V,logicalXor:()=>r.egP,losses:()=>r.MB5,lowerBound:()=>r.eab,matMul:()=>r.OI3,max:()=>r.Fp7,maxPool:()=>r._sB,maxPool3d:()=>r.YQQ,maxPoolWithArgmax:()=>r.Ip$,maximum:()=>r.gWQ,mean:()=>r.J69,meshgrid:()=>r.ry_,min:()=>r.VV$,minimum:()=>r.LTh,mirrorPad:()=>r.VdP,mod:()=>r.wQq,moments:()=>r.Gi7,movingAverage:()=>r.p_,mul:()=>r.dC7,multiRNNCell:()=>r.rq4,multinomial:()=>r.SJ_,neg:()=>r.W76,norm:()=>r.KOy,notEqual:()=>r.Quu,oneHot:()=>r.lfX,ones:()=>r.iUs,onesLike:()=>r.JpU,op:()=>r.op,outerProduct:()=>r.N2O,pad:()=>r.vku,pad1d:()=>r.pNR,pad2d:()=>r.koy,pad3d:()=>r.t1L,pad4d:()=>r.lGY,pool:()=>r.d_R,pow:()=>r.sQ3,prelu:()=>r.AL3,print:()=>r.S0v,prod:()=>r.WVs,raggedGather:()=>r.$gW,raggedRange:()=>r.VT$,raggedTensorToTensor:()=>r.N89,rand:()=>r.TN_,randomGamma:()=>r.wzB,randomNormal:()=>r.nGf,randomStandardNormal:()=>r.ruB,randomUniform:()=>r.LGj,range:()=>r.w6H,real:()=>r.kwC,reciprocal:()=>r.M25,relu:()=>r.UYe,relu6:()=>r.btT,reshape:()=>r.XLQ,reverse:()=>r.GYS,reverse1d:()=>r.SDf,reverse2d:()=>r.diP,reverse3d:()=>r.sx7,reverse4d:()=>r.mG2,rfft:()=>r.QEs,round:()=>r.NMM,rsqrt:()=>r.bp0,scalar:()=>r.iD$,scatterND:()=>r.snQ,searchSorted:()=>r.zcT,selu:()=>r.U8D,separableConv2d:()=>r.U_I,setdiff1dAsync:()=>r.ODp,sigmoid:()=>r.XD2,sign:()=>r.Xxe,signal:()=>r.tdS,sin:()=>r.O$l,sinh:()=>r.R_K,slice:()=>r.tPi,slice1d:()=>r.jZU,slice2d:()=>r.SmN,slice3d:()=>r.CnO,slice4d:()=>r.p0P,softmax:()=>r.XAC,softplus:()=>r.Wvh,spaceToBatchND:()=>r.fBT,sparse:()=>r.rVs,sparseToDense:()=>r.ers,spectral:()=>r.uN7,split:()=>r.Vl2,sqrt:()=>r._b3,square:()=>r.h62,squaredDifference:()=>r.$i,squeeze:()=>r.L9e,stack:()=>r.knu,step:()=>r.Nbs,stridedSlice:()=>r.NXj,string:()=>r.Z_8,sub:()=>r.luU,sum:()=>r.Smz,tan:()=>r.ORZ,tanh:()=>r.AEp,tensor:()=>r.XeE,tensor1d:()=>r.RRF,tensor2d:()=>r.odF,tensor3d:()=>r.wOQ,tensor4d:()=>r.yXz,tensor5d:()=>r.Bfx,tensor6d:()=>r.xZs,tile:()=>r.Gg6,topk:()=>r.hg7,transpose:()=>r.p4s,truncatedNormal:()=>r.Xu6,unique:()=>r.Two,unsortedSegmentSum:()=>r.pUJ,unstack:()=>r.HHK,upperBound:()=>r.GaM,variable:()=>r.VD$,where:()=>r.arb,whereAsync:()=>r.itS,zeros:()=>r.lls,zerosLike:()=>r.P84});var r=n(15863)},39682:(e,t,n)=>{n.d(t,{v:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({pad_:function(e,t,n=0){const i=(0,a._1)(e,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},l={x:i};return r.BV.runKernel(s.lyA,l,o)}})},33453:(e,t,n)=>{n.d(t,{s:()=>o});var r=n(23926),s=n(29121),a=n(80747),i=n(43740);const o=(0,n(2668).op)({pow_:function(e,t){let n=(0,i._1)(e,"base","pow"),o=(0,i._1)(t,"exp","pow");[n,o]=(0,a.T_)(n,o);const l={a:n,b:o};return r.BV.runKernel(s.pe_,l)}})},98151:(e,t,n)=>{n.d(t,{A:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({prelu_:function(e,t){const n={x:(0,a._1)(e,"x","prelu"),alpha:(0,a._1)(t,"alpha","prelu")};return r.BV.runKernel(s.o0g,n)}})},29798:(e,t,n)=>{function r(e,t=!1){console.log(e.toString(t))}n.d(t,{S:()=>r})},74825:(e,t,n)=>{var r;function s(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function a(e){const t={FIRST_DIM_SIZE:r.FIRST_DIM_SIZE,VALUE_ROWIDS:r.VALUE_ROWIDS,ROW_LENGTHS:r.ROW_LENGTHS,ROW_SPLITS:r.ROW_SPLITS,ROW_LIMITS:r.ROW_LIMITS,ROW_STARTS:r.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function i(e){return 0===e.length?0:e[0]===r.FIRST_DIM_SIZE?e.length-1:e.length}function o(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}n.d(t,{Qd:()=>s,Qh:()=>i,Ys:()=>o,b2:()=>r,zb:()=>a}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(r||(r={}))},56845:(e,t,n)=>{n.d(t,{T9:()=>a,Yi:()=>s,wv:()=>i});var r=n(36377);class s{constructor(e,t,n,s,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=a||Math.random();this.random=r.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class a{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const i=a||Math.random();this.randu=r.alea(i.toString()),this.randn=new s(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class i{constructor(e=0,t=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=r.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},75002:(e,t,n)=>{n.d(t,{L:()=>o});var r=n(20569),s=n(72657),a=n(2668),i=n(56845);const o=(0,a.op)({randomUniform_:function(e,t=0,n=1,a="float32",o){(0,r.Mu)(e);const l=(0,s.f)(e,a),u=new i.wv(t,n,null,o);for(let e=0;e<l.values.length;e++)l.values[e]=u.nextValue();return l.toTensor()}})},47245:(e,t,n)=>{n.d(t,{w:()=>a});var r=n(23926),s=n(29121);function a(e,t,n=1,a="float32"){if(0===n)throw new Error("Cannot have a step of zero");const i={start:e,stop:t,step:n,dtype:a};return r.BV.runKernel(s.e6w,{},i)}},60766:(e,t,n)=>{n.d(t,{k:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({real_:function(e){const t={input:(0,a._1)(e,"input","real")};return r.BV.runKernel(s.xJR,t)}})},25466:(e,t,n)=>{n.d(t,{A:()=>a,g:()=>s});var r=n(20569);const s=30;function a(e){return e<=s?e:(0,r.jP)(e,Math.floor(Math.sqrt(e)))}},7409:(e,t,n)=>{n.d(t,{U:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({relu_:function(e){const t={x:(0,a._1)(e,"x","relu")};return r.BV.runKernel(s.qkr,t)}})},83582:(e,t,n)=>{n.d(t,{b:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({relu6_:function(e){const t={x:(0,a._1)(e,"x","relu6")};return r.BV.runKernel(s.SbG,t)}})},4968:(e,t,n)=>{n.d(t,{X:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({reshape_:function(e,t){const n={x:(0,a._1)(e,"x","reshape","string_or_numeric")},i={shape:t};return r.BV.runKernel(s.HZH,n,i)}})},57486:(e,t,n)=>{n.d(t,{G:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({reverse_:function(e,t){const n={x:(0,a._1)(e,"x","reverse")},i={dims:t};return r.BV.runKernel(s.mKl,n,i)}})},29645:(e,t,n)=>{function r(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}n.d(t,{Q:()=>r})},97809:(e,t,n)=>{n.d(t,{N:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({round_:function(e){const t={x:(0,a._1)(e,"x","round")};return r.BV.runKernel(s.e07,t)}})},32634:(e,t,n)=>{n.d(t,{b:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({rsqrt_:function(e){const t={x:(0,a._1)(e,"x","rsqrt","float32")};return r.BV.runKernel(s.bV0,t)}})},99494:(e,t,n)=>{n.d(t,{i:()=>a});var r=n(59155),s=n(57852);function a(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.H)(e,[],[],t)}},33028:(e,t,n)=>{n.d(t,{SU:()=>i,b0:()=>a,l5:()=>s});var r=n(20569);function s(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function a(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}s(n,t,e)}function i(e,t,n){const s=t.shape.length,a=s>1?t.shape[s-1]:1,i=n.length;let o=1;for(let e=a;e<i;++e)o*=n[e];const l=a<1?1:a;return{sliceRank:a,numUpdates:(0,r.NA)(t.shape)/l,sliceSize:o,strides:[...(0,r.e3)(n.slice(0,a)),1],outputSize:(0,r.NA)(n)}}},43336:(e,t,n)=>{n.d(t,{z:()=>h});var r=n(23926),s=n(29121),a=n(43740),i=n(20569),o=n(2668),l=n(4968);const u=2147483648,h=(0,o.op)({searchSorted_:function(e,t,n="left"){const o=(0,a._1)(e,"sortedSequence","searchSorted"),h=(0,a._1)(t,"values","searchSorted"),c=o.shape[o.shape.length-1],d=h.shape[h.shape.length-1],p=(0,l.X)(o,[-1,c]),f=(0,l.X)(h,[-1,d]);if(p.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(p.shape[0]!==f.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,i.NA)(f.shape)>=u)throw new Error("values tensor size must less than 2147483648");if(p.shape[1]>=u)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${p.shape[1]}`);const m={sortedSequence:p,values:f},g={side:n};return r.BV.runKernel(s.nr8,m,g)}})},14931:(e,t,n)=>{n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>o,computeOutShape:()=>i,segOpComputeOptimalWindowSize:()=>a});var r=n(20569),s=n(25466);function a(e,t){let n,a=!1;for(e<=s.g?(n=e,a=!0):n=(0,r.jP)(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=(0,r.jP)(e,n+1);return n}function i(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function o(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let l=1,u=1,h=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),h*=e.shape[t];return{batchSize:l,sliceSize:h,outerSize:u,dimSize:i,outputShape:o}}},43179:(e,t,n)=>{n.d(t,{$:()=>s,y:()=>r});const r=1.7580993408473768,s=1.0507009873554805},30625:(e,t,n)=>{n.d(t,{X:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({sigmoid_:function(e){const t={x:(0,a._1)(e,"x","sigmoid","float32")};return r.BV.runKernel(s.a5O,t)}})},99331:(e,t,n)=>{n.d(t,{O:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({sin_:function(e){const t={x:(0,a._1)(e,"x","sin","float32")};return r.BV.runKernel(s.RQH,t)}})},83254:(e,t,n)=>{n.d(t,{R:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({sinh_:function(e){const t={x:(0,a._1)(e,"x","sinh")};return r.BV.runKernel(s.wYB,t)}})},22676:(e,t,n)=>{n.d(t,{t:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({slice_:function(e,t,n){const i=(0,a._1)(e,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const o={x:i},l={begin:t,size:n};return r.BV.runKernel(s.p2w,o,l)}})},37650:(e,t,n)=>{n.r(t),n.d(t,{assertParamsValid:()=>s,computeFlatOffset:()=>b,computeOutShape:()=>i,getNormalizedAxes:()=>h,isSliceContinous:()=>g,maskToAxes:()=>a,parseSliceParams:()=>y,sliceInfo:()=>w,startForAxis:()=>f,startIndicesWithElidedDims:()=>c,stopForAxis:()=>m,stopIndicesWithElidedDims:()=>d,stridesForAxis:()=>p,stridesWithElidedDims:()=>o});var r=n(20569);function s(e,t,n){const s=e.shape.length;r.hu(s===t.length,(()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),r.hu(s===n.length,(()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));for(let a=0;a<s;++a)r.hu(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${s}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function a(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function i(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function o(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function l(e,t,n){return n<=e?n:n-(t-1)}function u(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function h(e,t,n,r,s,a,i,l,u){const h=e.length;let g=new Array(h),b=new Array(h),y=new Array(h);if(t.length&&n>0){const u=t[0],h=n+1;g=c(i,u,h,r,e),b=d(l,u,h,s,e),y=o(a,u,h,e)}else for(let t=0;t<h;t++)g[t]=f(i,r,a,e,t,u),b[t]=m(l,s,a,e,t,u),y[t]=p(a,t,u);return{begin:g,end:b,strides:y}}function c(e,t,n,r,s){const a=[...s],i=u(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=l(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function d(e,t,n,s,a){const i=[...a],o=u(n,t);for(let r=0;r<i.length;r++)if(o.indexOf(r)>-1)i[r]=Number.MAX_SAFE_INTEGER;else{const a=l(t,n,r);let o=s[a];e&1<<a&&(o=Number.MAX_SAFE_INTEGER),i[r]=o}for(let e=0;e<i.length;e++){const t=a[e];i[e]<0&&(i[e]+=t),i[e]=r.uZ(0,i[e],a[e])}return i}function p(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function f(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=r.uZ(0,o,u-1),o}function m(e,t,n,s,a,i){let o=t[a];const l=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[a];return o<0&&(o+=u),o=l>0?r.uZ(0,o,u):r.uZ(-1,o,u-1),o}function g(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function b(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function y(e,t,n){let s;const a=e.shape.length;let i;return s="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),s.forEach((e=>{r.hu(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(r.hu(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-s[n]))),[s,i]}function w(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!=(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const c={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<c.dims;e++)h&&0!=(1<<e&o)&&c.numAddAxisAfterEllipsis++,1<<e&i&&(h=!0);h||(c.ellipsisMask|=1<<c.dims,c.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,d);let p=!0,f=!0,m=!0;const g=[],b=[];for(let t=0;t<e.length;++t){if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const s=[d.beginMask&1<<t,d.endMask&1<<t],a=[d.strides[t]>0?0:-1,d.strides[t]>0?r:r-1];if(n&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[t];const i=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(n){const e=d.begin[t]<0?r+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=r)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=v(d.begin[t],0,d.strides[t],r,s,a),d.end[t]=v(d.end[t],1,d.strides[t],r,s,a);const e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===r;p=p&&e,f=f&&(0===t&&1===d.strides[t]||e)}else p=p&&1===d.strides[t]&&i,f=f&&(0===t&&1===d.strides[t]||i);let o,l=!1;if(d.beginValid&&d.endValid?(o=d.end[t]-d.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=d.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=d.strides[t]<0?0:Math.trunc(o/d.strides[t])+(o%d.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){const t=d.finalShapeGatherIndices[e];t>=0?b.push(g[t]):-2===t&&b.push(1)}return{finalShapeSparse:b.filter(((e,t)=>-2!==d.finalShapeGatherIndices[t])),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function v(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}},3694:(e,t,n)=>{n.d(t,{W:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({softplus_:function(e){const t={x:(0,a._1)(e,"x","softplus")};return r.BV.runKernel(s.MRv,t)}})},27918:(e,t,n)=>{n.d(t,{f:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(20569);const o=(0,n(2668).op)({spaceToBatchND_:function(e,t,n){const o=(0,a._1)(e,"x","spaceToBatchND");i.hu(o.rank>=1+t.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`)),i.hu(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),i.hu(o.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const l={x:o},u={blockShape:t,paddings:n};return r.BV.runKernel(s.TQc,l,u)}})},90820:(e,t,n)=>{function r(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function s(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function a(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}n.d(t,{E3:()=>s,I_:()=>a,h:()=>r})},49139:(e,t,n)=>{n.d(t,{Y6:()=>a,aY:()=>l,rP:()=>i,y5:()=>s,yv:()=>o});var r=n(20569);function s(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function a(e,t){return`size ${e} must be non-negative, not ${t}`}function i(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function o(e,t){return`Input to reshape is a SparseTensor with ${(0,r.NA)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,r.NA)(t)}. inputShape=${e} outputShape= ${t}`}function l(e,t){return`Input to reshape is a tensor with ${(0,r.NA)(e)} dense values, but the requested shape has ${(0,r.NA)(t)}. inputShape=${e} outputShape=${t}`}},88153:(e,t,n)=>{function r(){return"segment ids must be >= 0"}function s(){return"segment ids are not increasing"}function a(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function i(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}n.d(t,{GW:()=>a,N5:()=>r,XL:()=>s,u6:()=>i})},28644:(e,t,n)=>{n.d(t,{V:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({split_:function(e,t,n=0){const i={x:(0,a._1)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return r.BV.runKernel(s.L8s,i,o)}})},34099:(e,t,n)=>{n.d(t,{O:()=>s});var r=n(20569);function s(e,t,n=0){let s=[];if("number"==typeof t)(0,r.hu)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),s=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,r.hu)(a<=1,(()=>"There should be only one negative value in split array."));const i=t.indexOf(-1);if(-1!==i){const r=t.reduce(((e,t)=>t>0?e+t:e));t[i]=e.shape[n]-r}(0,r.hu)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),s=t}return s}},13261:(e,t,n)=>{n.d(t,{_:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({sqrt_:function(e){const t={x:(0,a._1)(e,"x","sqrt","float32")};return r.BV.runKernel(s.FKq,t)}})},50248:(e,t,n)=>{n.d(t,{h:()=>a});var r=n(23926),s=n(43740);const a=(0,n(2668).op)({square_:function(e){const t=(0,s._1)(e,"x","square");return r.BV.runKernel("Square",{x:t},{})}})},15265:(e,t,n)=>{n.d(t,{$:()=>l});var r=n(23926),s=n(29121),a=n(80747),i=n(43740),o=n(72200);const l=(0,n(2668).op)({squaredDifference_:function(e,t){let n=(0,i._1)(e,"a","squaredDifference"),l=(0,i._1)(t,"b","squaredDifference");[n,l]=(0,a.T_)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.BV.runKernel(s._tC,u,{})}})},79590:(e,t,n)=>{n.d(t,{L:()=>o});var r=n(43740),s=n(20569),a=n(2668),i=n(4968);const o=(0,a.op)({squeeze_:function(e,t){const n=(0,r._1)(e,"x","squeeze","string_or_numeric");return(0,i.X)(n,(0,s.bp)(n.shape,t).newShape)}})},82991:(e,t,n)=>{n.d(t,{k:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(20569);const o=(0,n(2668).op)({stack_:function(e,t=0){const n=(0,a.sI)(e,"tensors","stack","string_or_numeric");i.hu(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&i.hu(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const o=n,l={axis:t};return r.BV.runKernel(s.QiL,o,l)}})},71901:(e,t,n)=>{n.d(t,{N:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({step_:function(e,t=0){const n={x:(0,a._1)(e,"x","step")},i={alpha:t};return r.BV.runKernel(s.h8e,n,i)}})},70827:(e,t,n)=>{n.d(t,{l:()=>o});var r=n(23926),s=n(29121),a=n(80747),i=n(43740);const o=(0,n(2668).op)({sub_:function(e,t){let n=(0,i._1)(e,"a","sub"),o=(0,i._1)(t,"b","sub");[n,o]=(0,a.T_)(n,o);const l={a:n,b:o};return r.BV.runKernel(s.Tr8,l)}})},15475:(e,t,n)=>{n.d(t,{S:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(62271);const o=(0,n(2668).op)({sum_:function(e,t=null,n=!1){let o=(0,a._1)(e,"x","sum");"bool"===o.dtype&&(o=(0,i.p)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.BV.runKernel(s.GBy,l,u)}})},21869:(e,t,n)=>{n.d(t,{A:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({tanh_:function(e){const t={x:(0,a._1)(e,"x","tanh","float32")};return r.BV.runKernel(s.MIZ,t)}})},10701:(e,t,n)=>{n.d(t,{X:()=>a});var r=n(43740),s=n(57852);function a(e,t,n){const a=(0,r.C)(e,n);return(0,s.H)(e,t,a,n)}},46092:(e,t,n)=>{n.d(t,{R:()=>i});var r=n(43740),s=n(20569),a=n(57852);function i(e,t){(0,s.Cq)(e);const n=(0,r.C)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,a.H)(e,null,n,t)}},24376:(e,t,n)=>{n.d(t,{o:()=>i});var r=n(43740),s=n(20569),a=n(57852);function i(e,t,n){if((0,s.Cq)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const i=(0,r.C)(e,n);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,a.H)(e,t,i,n)}},99906:(e,t,n)=>{n.d(t,{w:()=>i});var r=n(43740),s=n(20569),a=n(57852);function i(e,t,n){if((0,s.Cq)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=(0,r.C)(e,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,a.H)(e,t,i,n)}},57852:(e,t,n)=>{n.d(t,{H:()=>i});var r=n(23926),s=n(20569),a=n(59155);function i(e,t,n,i){if(null==i)i=(0,s.D2)(e);else if("complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof e&&("texture"in e||"buffer"in e&&!(e.buffer instanceof ArrayBuffer))){if("float32"!==i&&"int32"!==i)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${i}.`);return r.BV.backend.createTensorFromGPUData(e,t||n,i)}if(!(0,a.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,s.Mu)(t);const e=(0,s.NA)(t),r=(0,s.NA)(n);(0,s.hu)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],a=e!==n.length-1||r!==(0,s.NA)(t.slice(e));(0,s.hu)(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,a.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==i?(0,a.toTypedArray)(e,i):(0,a.flatten)(e,[],!0),r.BV.makeTensor(e,t,i)}},47501:(e,t,n)=>{n.d(t,{G:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(20569);const o=(0,n(2668).op)({tile_:function(e,t){const n=(0,a._1)(e,"x","tile","string_or_numeric");i.hu(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const o={x:n},l={reps:t};return r.BV.runKernel(s.n9L,o,l)}})},89065:(e,t,n)=>{n.d(t,{p:()=>p});var r=n(23926),s=n(4368),a=n(29121),i=n(43740),o=n(20569),l=n(61661),u=n(64386),h=n(17370),c=n(2668),d=n(60766);const p=(0,c.op)({transpose_:function(e,t,n){const c=(0,i._1)(e,"x","transpose");if(null==t&&(t=c.shape.map(((e,t)=>t)).reverse()),o.hu(c.rank===t.length,(()=>`Error in transpose: rank of input ${c.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.hu(e>=0&&e<c.rank,(()=>"All entries in 'perm' must be between 0 and "+(c.rank-1)+` but got ${t}`))})),c.rank<=1)return c.clone();const p={x:c},f={perm:t};return"complex64"===c.dtype?(0,s.lu)((()=>{let e=(0,d.k)(c),t=(0,u.a)(c);return e=r.BV.runKernel(a.G3Y,{x:e},f),t=r.BV.runKernel(a.G3Y,{x:t},f),n&&(t=(0,h.W)(t)),(0,l.P)(e,t)})):r.BV.runKernel(a.G3Y,p,f)}})},98749:(e,t,n)=>{n.d(t,{p:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(20569);const o=(0,n(2668).op)({unsortedSegmentSum_:function(e,t,n){const o=(0,a._1)(e,"x","unsortedSegmentSum"),l=(0,a._1)(t,"segmentIds","unsortedSegmentSum","int32");(0,i.hu)((0,i.GN)(n),(()=>"numSegments must be of dtype int"));const u={x:o,segmentIds:l},h={numSegments:n};return r.BV.runKernel(s.Qvg,u,h)}})},24136:(e,t,n)=>{n.d(t,{H:()=>o});var r=n(23926),s=n(29121),a=n(43740),i=n(20569);const o=(0,n(2668).op)({unstack_:function(e,t=0){const n=(0,a._1)(e,"x","unstack","string_or_numeric");i.hu(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const o={value:n},l={axis:t};return r.BV.runKernel(s.ToN,o,l)}})},95912:(e,t,n)=>{n.d(t,{a:()=>l});var r=n(23926),s=n(29121),a=n(43740),i=n(68247),o=n(72200);const l=(0,n(2668).op)({where_:function(e,t,n){const l=(0,a._1)(t,"a","where"),u=(0,a._1)(n,"b","where"),h=(0,a._1)(e,"condition","where","bool"),c=(0,o.assertAndGetBroadcastShape)((0,o.assertAndGetBroadcastShape)(h.shape,l.shape),u.shape),d={condition:(0,i.U)(h,c),t:(0,i.U)(l,c),e:(0,i.U)(u,c)};return r.BV.runKernel(s.PhF,d)}})},66380:(e,t,n)=>{n.d(t,{i:()=>a});var r=n(48333),s=n(43740);const a=async function(e){const t=(0,s._1)(e,"condition","whereAsync","bool"),n=await t.data(),a=(0,r.Z)(t.shape,n);return e!==t&&t.dispose(),a}},59640:(e,t,n)=>{n.d(t,{l:()=>i});var r=n(23926),s=n(20569),a=n(61661);function i(e,t="float32"){if((0,s.Mu)(e),"complex64"===t){const t=i(e,"float32"),n=i(e,"float32");return(0,a.P)(t,n)}const n=(0,s.wT)((0,s.NA)(e),t);return r.BV.makeTensor(n,e,t)}},6577:(e,t,n)=>{n.d(t,{P:()=>i});var r=n(23926),s=n(29121),a=n(43740);const i=(0,n(2668).op)({zerosLike_:function(e){const t={x:(0,a._1)(e,"x","zerosLike")};return r.BV.runKernel(s.RuY,t)}})},12134:(e,t,n)=>{n.d(t,{z:()=>d});var r=n(23926),s=n(4368),a=n(56407),i=n(41274),o=n(24841),l=n(13261),u=n(50248),h=n(6577),c=n(61015);class d extends c.g{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=r.BV.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const c=r.BV.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,s.lu)((()=>(0,h.P)(c).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,s.lu)((()=>(0,h.P)(c).variable(!1)))});const d=Array.isArray(e)?e[n].tensor:e[t];if(null==d)return;const p=this.accumulatedGrads[n].variable,f=this.accumulatedUpdates[n].variable;(0,s.lu)((()=>{const e=(0,a.I)((0,o.d)(p,this.rho),(0,o.d)((0,u.h)(d),1-this.rho)),t=(0,o.d)((0,i.h)((0,l._)((0,a.I)(f,this.epsilon)),(0,l._)((0,a.I)(p,this.epsilon))),d),n=(0,a.I)((0,o.d)(f,this.rho),(0,o.d)((0,u.h)(t),1-this.rho));p.assign(e),f.assign(n);const r=(0,a.I)((0,o.d)(t,-this.learningRate),c);c.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,s.B9)(this.accumulatedGrads.map((e=>e.variable))),(0,s.B9)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}},52515:(e,t,n)=>{n.d(t,{H:()=>d});var r=n(23926),s=n(4368),a=n(56407),i=n(41274),o=n(14006),l=n(24841),u=n(13261),h=n(50248),c=n(61015);class d extends c.g{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const c=r.BV.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,s.lu)((()=>(0,o.h)(c.shape,this.initialAccumulatorValue).variable(e)))}}const d=Array.isArray(e)?e[n].tensor:e[t];if(null==d)return;const p=this.accumulatedGrads[n].variable;(0,s.lu)((()=>{const e=(0,a.I)(p,(0,h.h)(d));p.assign(e);const t=(0,a.I)((0,l.d)((0,i.h)(d,(0,u._)((0,a.I)(e,r.BV.backend.epsilon()))),-this.learningRate),c);c.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,s.B9)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}},77463:(e,t,n)=>{n.d(t,{a:()=>m});var r=n(23926),s=n(4368),a=n(56407),i=n(41274),o=n(24841),l=n(33453),u=n(99494),h=n(13261),c=n(50248),d=n(70827),p=n(6577),f=n(61015);class m extends f.g{constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,s.lu)((()=>{this.accBeta1=(0,u.i)(t).variable(),this.accBeta2=(0,u.i)(n).variable()})),null==a&&(this.epsilon=r.BV.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,s.lu)((()=>{const n=(0,d.l)(1,this.accBeta1),l=(0,d.l)(1,this.accBeta2);t.forEach(((t,u)=>{const d=r.BV.registeredVariables[t];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${t}/m`,variable:(0,s.lu)((()=>(0,p.P)(d).variable(!1)))}),null==this.accumulatedSecondMoment[u]&&(this.accumulatedSecondMoment[u]={originalName:`${t}/v`,variable:(0,s.lu)((()=>(0,p.P)(d).variable(!1)))});const f=Array.isArray(e)?e[u].tensor:e[t];if(null==f)return;const m=this.accumulatedFirstMoment[u].variable,g=this.accumulatedSecondMoment[u].variable,b=(0,a.I)((0,o.d)(m,this.beta1),(0,o.d)(f,1-this.beta1)),y=(0,a.I)((0,o.d)(g,this.beta2),(0,o.d)((0,c.h)(f),1-this.beta2)),w=(0,i.h)(b,n),v=(0,i.h)(y,l);m.assign(b),g.assign(y);const _=(0,a.I)((0,o.d)((0,i.h)(w,(0,a.I)((0,h._)(v),this.epsilon)),-this.learningRate),d);d.assign(_)})),this.accBeta1.assign((0,o.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,o.d)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,s.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,s.B9)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,s.lu)((()=>{this.accBeta1.assign((0,l.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,l.s)(this.beta2,this.iterations_+1))}));const t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}},23888:(e,t,n)=>{n.d(t,{D:()=>f});var r=n(23926),s=n(4368),a=n(96235),i=n(56407),o=n(41274),l=n(80632),u=n(24841),h=n(99494),c=n(70827),d=n(6577),p=n(61015);class f extends p.g{constructor(e,t,n,a=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,s.lu)((()=>{this.iteration=(0,h.i)(0).variable(),this.accBeta1=(0,h.i)(t).variable()})),null==a&&(this.epsilon=r.BV.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,s.lu)((()=>{const n=(0,c.l)(1,this.accBeta1),s=(0,o.h)(-this.learningRate,(0,i.I)((0,u.d)(this.iteration,this.decay),1));t.forEach(((t,h)=>{const c=r.BV.registeredVariables[t];null==this.accumulatedFirstMoment[h]&&(this.accumulatedFirstMoment[h]={originalName:`${t}/m`,variable:(0,d.P)(c).variable(!1)}),null==this.accumulatedWeightedInfNorm[h]&&(this.accumulatedWeightedInfNorm[h]={originalName:`${t}/v`,variable:(0,d.P)(c).variable(!1)});const p=Array.isArray(e)?e[h].tensor:e[t];if(null==p)return;const f=this.accumulatedFirstMoment[h].variable,m=this.accumulatedWeightedInfNorm[h].variable,g=(0,i.I)((0,u.d)(f,this.beta1),(0,u.d)(p,1-this.beta1)),b=(0,u.d)(m,this.beta2),y=(0,a.W)(p),w=(0,l.g)(b,y);f.assign(g),m.assign(w);const v=(0,i.I)((0,u.d)((0,o.h)(s,n),(0,o.h)(g,(0,i.I)(w,this.epsilon))),c);c.assign(v)})),this.iteration.assign((0,i.I)(this.iteration,1)),this.accBeta1.assign((0,u.d)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,s.B9)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,s.B9)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}},9406:(e,t,n)=>{n.d(t,{r:()=>h});var r=n(23926),s=n(4368),a=n(56407),i=n(24841),o=n(99494),l=n(6577),u=n(75726);class h extends u.D{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,o.i)(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=r.BV.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,s.lu)((()=>(0,l.P)(o).variable(e)))}}const u=this.accumulations[n].variable,h=Array.isArray(e)?e[n].tensor:e[t];null!=h&&(0,s.lu)((()=>{let e;const t=(0,a.I)((0,i.d)(this.m,u),h);e=this.useNesterov?(0,a.I)((0,i.d)(this.c,(0,a.I)(h,(0,i.d)(t,this.m))),o):(0,a.I)((0,i.d)(this.c,t),o),u.assign(t),o.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,s.B9)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}},61015:(e,t,n)=>{n.d(t,{g:()=>o});var r=n(4368),s=n(30633),a=n(99494),i=n(53393);class o extends i.Serializable{minimize(e,t=!1,n){const{value:s,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return(0,r.B9)(a),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,s.pn)(e,t)}dispose(){null!=this.iterations_&&(0,r.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,a.i)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(o,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients})},18362:(e,t,n)=>{n.d(t,{V:()=>d});var r=n(12134),s=n(52515),a=n(77463),i=n(23888),o=n(9406),l=n(24803),u=n(75726),h=n(53393);const c=[r.z,s.H,a.a,i.D,o.r,l.g,u.D];function d(){for(const e of c)(0,h.registerClass)(e)}},24803:(e,t,n)=>{n.d(t,{g:()=>p});var r=n(23926),s=n(4368),a=n(56407),i=n(41274),o=n(24841),l=n(13261),u=n(50248),h=n(70827),c=n(6577),d=n(61015);class p extends d.g{constructor(e,t=.9,n=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==s&&(this.epsilon=r.BV.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const d=r.BV.registeredVariables[t],p=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,s.lu)((()=>(0,c.P)(d).variable(p)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,s.lu)((()=>(0,c.P)(d).variable(p)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,s.lu)((()=>(0,c.P)(d).variable(p)))});const f=Array.isArray(e)?e[n].tensor:e[t];if(null==f)return;const m=this.accumulatedMeanSquares[n].variable,g=this.accumulatedMoments[n].variable;(0,s.lu)((()=>{const e=(0,a.I)((0,o.d)(m,this.decay),(0,o.d)((0,u.h)(f),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=(0,a.I)((0,o.d)(t,this.decay),(0,o.d)(f,1-this.decay)),s=(0,i.h)((0,o.d)(f,this.learningRate),(0,l._)((0,h.l)(e,(0,a.I)((0,u.h)(r),this.epsilon)))),c=(0,a.I)((0,o.d)(g,this.momentum),s);m.assign(e),t.assign(r),g.assign(c);const p=(0,h.l)(d,c);d.assign(p)}else{const e=(0,a.I)((0,o.d)(m,this.decay),(0,o.d)((0,u.h)(f),1-this.decay)),t=(0,a.I)((0,o.d)(g,this.momentum),(0,i.h)((0,o.d)(f,this.learningRate),(0,l._)((0,a.I)(e,this.epsilon))));m.assign(e),g.assign(t);const n=(0,h.l)(d,t);d.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,s.B9)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,s.B9)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,s.B9)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}},75726:(e,t,n)=>{n.d(t,{D:()=>u});var r=n(23926),s=n(4368),a=n(56407),i=n(24841),o=n(99494),l=n(61015);class u extends l.g{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const l=r.BV.registeredVariables[t];(0,s.lu)((()=>{const e=(0,a.I)((0,i.d)(this.c,o),l);l.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,s.Cn)((0,o.i)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}},26480:(e,t,n)=>{n(79998);var r=n(22885),s=n(61044),a=n(28209),i=n(90780);class o{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&(0,r.OB)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if((0,r.OB)().get("IS_BROWSER")){(0,r.OB)().setPlatform("browser",new o);try{i.xQ.registerManager(a.Ew.URL_SCHEME,new a.JL)}catch(e){}try{i.xQ.registerManager(s.ns.URL_SCHEME,new s.y$)}catch(e){}}},35221:(e,t,n)=>{var r=n(22885);let s;(0,r.OB)().get("IS_NODE")&&!(0,r.OB)().get("IS_BROWSER")&&(0,r.OB)().setPlatform("node",new class{constructor(){this.util=n(48628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,r.OB)().global.fetch?(0,r.OB)().global.fetch(e,t):(null==s&&(s=n(75410)),s(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}})},52368:(e,t,n)=>{n.d(t,{Q1:()=>i});var r=n(22885),s=n(59155),a=n(20569);class i{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new l)}profileKernel(e,t,n){let a;const i=()=>{a=n()};let l;const u=s.now();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(i);else{i();for(const e of a)e.dataSync();l=Promise.resolve({kernelMs:s.now()-u})}if((0,r.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<a.length;t++){const n=a[t];n.data().then((t=>{o(t,n.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:l.then((e=>e.kernelMs)),extraInfo:l.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function o(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class l{logKernelProfile(e,t,n,r,s,i){const o="number"==typeof r?a.oj(`${r}ms`,9):r.error,l=a.oj(e,25),u=t.rank,h=t.size,c=a.oj(t.shape.toString(),14);let d="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;d+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${l}\t%c${o}\t%c${u}D ${c}\t%c${h}\t%c${d}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}},88940:(e,t,n)=>{var r=n(32259),s=n(35589),a=n(10629),i=n(18707),o=n(42724),l=n(64017),u=n(67851),h=n(20080),c=n(11669),d=n(55535),p=n(23755),f=n(87242),m=n(92153),g=n(24254),b=n(9742),y=n(3477),w=n(27914),v=n(42680),_=n(49467),$=n(57777),S=n(38323),k=n(54565),x=n(45396),E=n(9920),A=n(77355),T=n(77528),I=n(61763),N=n(12090),M=n(303),V=n(62207),B=n(29479),R=n(82221),D=n(15833),G=n(45920),C=n(72087),P=n(30782),W=n(18284),O=n(38905),q=n(66568),z=n(3258),F=n(91603),K=n(13079),U=n(8474),L=n(48971),j=n(78412),H=n(74937),X=n(72486),Q=n(7759),Y=n(54488),Z=n(62850),J=n(25241),ee=n(7400),te=n(32282),ne=n(37482),re=n(22735),se=n(50629),ae=n(48594),ie=n(74812),oe=n(75508),le=n(26447),ue=n(30154),he=n(63668),ce=n(40436),de=n(99),pe=n(45370),fe=n(96587),me=n(18030),ge=n(91766),be=n(60006),ye=n(76179),we=n(15938),ve=n(15997),_e=n(55253),$e=n(84998),Se=n(95906),ke=n(30027),xe=n(37699),Ee=n(7504),Ae=n(82606),Te=n(45777),Ie=n(80125),Ne=n(94936),Me=n(77145),Ve=n(22154),Be=n(82232),Re=n(71372),De=n(18558),Ge=n(32439),Ce=n(30595),Pe=n(40521),We=n(79719),Oe=n(81554),qe=n(9460),ze=n(14574),Fe=n(83933),Ke=n(47320),Ue=n(272),Le=n(22625),je=n(23489),He=n(52679),Xe=n(51466),Qe=n(26151);const Ye=[r.Q,s.K,a.M,i.m,o.C,l.C,u.Q,h.V,c.f,d.H,p.A,f.q,m.Y,g.v,b.C,y.s,w.O,v.D,_.t,$.v,S.Q,k.x,E.F,x.S,A.w,T.L,I.a,N.g,M.v,V.T,ge.Z,B.q,R.j,D.K,G.B,C.g,W.T,P.G,O.c,q.t,z.i,F.w,K.Y,U.i,L.W,j.T,H.P,X.X,Q.K,Y.e,Z.J,Z.J,J.R,ee.J,te.f,ne.m,re.j,se.c,ae.i,ie.E,oe.q,le.R,ue.p,he.N,ce.n,de.G,de.G,pe.i,fe.d,me.X,be.a,ye.d,we.T,ve.H,_e.G,$e.S,Se.T,ke.O,xe.C,Ee.X,Ae.W,Te.E,Ie.Q,Ne._,Me.m,Ve.M,Be.J,Re.H,De.a,De.a,Ge.n,Ge.n,Ce.C,We.k,Pe.t,Oe.l,qe.h,ze.y,Fe.w,Ke.W,Ue.x,Le.j,je.T,He.x,Xe.a];for(const e of Ye)(0,Qe.Li)(e)},53393:(e,t,n)=>{n.r(t),n.d(t,{Serializable:()=>s,SerializationMap:()=>a,registerClass:()=>i});var r=n(20569);class s{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class a{constructor(){this.classNameMap={}}static getMap(){return null==a.instance&&(a.instance=new a),a.instance}static register(e){a.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function i(e){(0,r.hu)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,r.hu)("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,r.hu)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),a.register(e)}},50223:(e,t,n)=>{n.d(t,{C:()=>s,_:()=>a});var r=n(20569);function s(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}function a(e,t,n,s){for(let a=t.length-1;a>=0;a--){const i=t[a],o=[];if(i.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const t in i.inputs){if(!(t in l))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(l)}.`);const a=n((()=>l[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const o=i.inputs[t];if(!r.cO(a.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{const t=e[o.id];e[o.id]=s(t,a),t.dispose()}}}}},4077:(e,t,n)=>{n.d(t,{es:()=>y,YD:()=>c,_w:()=>w,FZ:()=>b,Vp:()=>g,Vi:()=>m});var r=n(55938),s=n(20569);function a(e,t,n,r){const a=(0,s.e3)(t),o=function(e,t,n,r){const a=(0,s.NA)(t),o=r[r.length-1],l=new Array(o).fill(0),h=t.length,c="complex64"===n?u(e):e;if(h>1)for(let e=0;e<a/o;e++){const t=e*o;for(let e=0;e<o;e++)l[e]=Math.max(l[e],i(c[t+e],0,n).length)}return l}(e,t,n,a),h=t.length,c=l(e,t,n,a,o),d=["Tensor"];return r&&(d.push(`  dtype: ${n}`),d.push(`  rank: ${h}`),d.push(`  shape: [${t}]`),d.push("  values:")),d.push(c.map((e=>"    "+e)).join("\n")),d.join("\n")}function i(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:(0,s.HD)(e)?`'${e}'`:"bool"===n?o(e):parseFloat(e.toFixed(7)).toString(),(0,s.oj)(r,t)}function o(e){return 0===e?"false":"true"}function l(e,t,n,r,s,a=!0){const h="complex64"===n?2:1,c=t[0],d=t.length;if(0===d)return"complex64"===n?[i(u(e)[0],0,n)]:"bool"===n?[o(e[0])]:[e[0].toString()];if(1===d){if(c>20){const t=3*h;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((c-3)*h,c*h));return"complex64"===n&&(r=u(r),a=u(a)),["["+r.map(((e,t)=>i(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>i(e,s[c-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?u(e):Array.from(e)).map(((e,t)=>i(e,s[t],n))).join(", ")+"]"]}const p=t.slice(1),f=r.slice(1),m=r[0]*h,g=[];if(c>20){for(let t=0;t<3;t++){const r=t*m,a=r+m;g.push(...l(e.slice(r,a),p,n,f,s,!1))}g.push("...");for(let t=c-3;t<c;t++){const r=t*m,a=r+m;g.push(...l(e.slice(r,a),p,n,f,s,t===c-1))}}else for(let t=0;t<c;t++){const r=t*m,a=r+m;g.push(...l(e.slice(r,a),p,n,f,s,t===c-1))}const b=2===d?",":"";g[0]="["+(c>0?g[0]+b:"");for(let e=1;e<g.length-1;e++)g[e]=" "+g[e]+b;let y=",\n";for(let e=2;e<d;e++)y+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(a?"":y),g}function u(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var h=n(59155);class c{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=s.NA(e),null!=n){const e=n.length;s.hu(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||s.rQ(t,this.size),this.strides=(0,s.e3)(e)}set(e,...t){0===t.length&&(t=[0]),s.hu(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return d().makeTensor(this.values,this.shape,this.dtype)}}let d=null,p=null,f=null;function m(e){d=e}function g(e){p=e}function b(e){f=e}class y{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=s.NA(e),this.strides=(0,s.e3)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return p.buffer(this.shape,this.dtype,e)}bufferSync(){return p.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,s.GX)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,s.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=d().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>h.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),d().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=d().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>h.decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await d().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(d().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return p.print(this,e)}clone(){return this.throwIfDisposed(),p.clone(this)}toString(e=!1){return a(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),p.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),d().makeVariable(this,e,t,n)}}Object.defineProperty(y,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),(0,r.R)("Tensor",(()=>y));class w extends y{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!s.cO(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);d().disposeTensor(this),this.dataId=e.dataId,d().incRef(this,null)}dispose(){d().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(w,Symbol.hasInstance,{value:e=>e instanceof y&&null!=e.assign&&e.assign instanceof Function})},80747:(e,t,n)=>{n.d(t,{T_:()=>i,Vu:()=>l,xg:()=>o});var r=n(4077),s=n(71221),a=n(20569);function i(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,s.x8)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){(0,a.hu)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function l(e){const t=[];return u(e,t,new Set),t}function u(e,t,n){if(null==e)return;if(e instanceof r.es)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!=typeof s)return;var s;const a=e;for(const e in a){const r=a[e];n.has(r)||(n.add(r),u(r,t,n))}}},43740:(e,t,n)=>{n.d(t,{C:()=>l,_1:()=>c,sI:()=>d});var r=n(23926),s=n(22885),a=n(4077),i=n(59155),o=n(20569);function l(e,t){let n=e;if((0,i.isTypedArray)(e))return"string"===t?[]:[e.length];if("object"==typeof e){if("texture"in e){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if("buffer"in e&&!(e.buffer instanceof ArrayBuffer))return[e.buffer.size/(null==t?4:(0,o.bT)(t))]}if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,i.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,s.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&u(e,r,[]),r}function u(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,i.isTypedArray)(e))return void(0,o.hu)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,o.hu)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,o.hu)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)u(e[t],r,n.concat(t))}function h(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function c(e,t,n,s="numeric"){if(e instanceof a.es)return h(s,e.dtype,t,n),e;let u=(0,o.D2)(e);if("string"!==u&&["bool","int32","float32"].indexOf(s)>=0&&(u=s),h(s,u,t,n),null==e||!(0,i.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const c=l(e,u);(0,i.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const d="string"!==u?(0,i.toTypedArray)(e,u):(0,i.flatten)(e,[],!0);return r.BV.makeTensor(d,c,u)}function d(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>c(e,`${t}[${s}]`,n,r)))}},7472:(e,t,n)=>{n.d(t,{p:()=>h});var r=n(12134),s=n(52515),a=n(77463),i=n(23888),o=n(9406),l=n(24803),u=n(75726);const h=class{static sgd(e){return new u.D(e)}static momentum(e,t,n=!1){return new o.r(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new l.g(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new a.a(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new r.z(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new i.D(e,t,n,r,s)}static adagrad(e,t=.1){return new s.H(e,t)}}},71221:(e,t,n)=>{var r,s,a,i,o;n.d(t,{x8:()=>u,z4:()=>h}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(a||(a={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const l={float32:i,int32:s,bool:a,complex64:o};function u(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return l[e][t]}function h(e){return u(e,"int32")}},59155:(e,t,n)=>{n.r(t),n.d(t,{arraysEqual:()=>s.cO,assert:()=>s.hu,assertNonNegativeIntegerDimensions:()=>s.Mu,assertNonNull:()=>s.Cq,assertShapesMatch:()=>s.k5,bytesFromStringArray:()=>s.Ub,bytesPerElement:()=>s.bT,checkConversionForErrors:()=>s.D5,clamp:()=>s.uZ,computeStrides:()=>s.e3,convertBackendValuesAndArrayBuffer:()=>s.KS,createScalarValue:()=>i,createShuffledIndices:()=>s.U$,decodeString:()=>c,distSquared:()=>s.E7,encodeString:()=>h,fetch:()=>u,fingerPrint64:()=>a.O,flatten:()=>p,getArrayFromDType:()=>s.rQ,getTypedArrayFromDType:()=>s.WP,hasEncodingLoss:()=>s.QB,hexToLong:()=>a.E,indexToLoc:()=>s.NE,inferDtype:()=>s.D2,inferFromImplicitShape:()=>s.JZ,isBoolean:()=>s.jn,isFunction:()=>s.mf,isInt:()=>s.GN,isNumber:()=>s.hj,isPromise:()=>s.tI,isScalarShape:()=>s.xH,isString:()=>s.HD,isTypedArray:()=>d,isValidDtype:()=>s.LP,locToIndex:()=>s.qy,makeOnesTypedArray:()=>s.p8,makeZerosNestedTypedArray:()=>s.l6,makeZerosTypedArray:()=>s.wT,nearestDivisor:()=>s.jP,nearestLargerEven:()=>s.nY,now:()=>l,parseAxisParam:()=>s.EC,randUniform:()=>s.bj,repeatedTry:()=>s.WD,rightPad:()=>s.oj,shuffle:()=>s.TV,shuffleCombo:()=>s.d7,sizeFromShape:()=>s.NA,sizeToSquarishShape:()=>s.YP,squeezeShape:()=>s.bp,sum:()=>s.Sm,swap:()=>s.LF,tanh:()=>s.AE,toNestedArray:()=>s.GX,toTypedArray:()=>o});var r=n(22885),s=n(20569),a=n(78194);function i(e,t){return"string"===t?h(e):o([e],t)}function o(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=p(e)),(0,r.OB)().getBool("DEBUG")&&s.D5(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function l(){return(0,r.OB)().platform.now()}function u(e,t){return(0,r.OB)().platform.fetch(e,t)}function h(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.encode(e,t)}function c(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.decode(e,t)}function d(e){return(0,r.OB)().platform.isTypedArray(e)}function p(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||s.tI(e)||null==e||d(e)&&n)t.push(e);else if(Array.isArray(e)||d(e))for(let r=0;r<e.length;++r)p(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)p(e[s],t,n)}return t}},20569:(e,t,n)=>{function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function s(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,o(e,n,r),o(t,n,r)}function a(e,t,n){return Math.max(e,Math.min(t,n))}function i(e){return e%2==0?e:e+1}function o(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function h(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function c(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function d(e,t,n=""){c(g(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){c(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function m(e){return 0===e.length}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function b(e){return e%1==0}function y(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function w(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function v(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function _(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function $(e,t=(e=>0),n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function S(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function k(e,t){const n=t.length;return c((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),c(e.every((e=>b(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function x(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:k(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function E(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function A(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function T(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function I(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function N(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function M(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function V(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function B(e){return"string"==typeof e||e instanceof String}function R(e){return"boolean"==typeof e}function D(e){return"number"==typeof e}function G(e){return Array.isArray(e)?G(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":D(e)?"float32":B(e)?"string":R(e)?"bool":"float32"}function C(e){return!!(e&&e.constructor&&e.call&&e.apply)}function P(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function W(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function O(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=O(e+t*o,i,n,r)}return s}function q(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return O(0,e,t,n)}function z(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function F(e,t){const n=K(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function K(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function U(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return q(e,new Float32Array(n));if("int32"===t)return q(e,new Int32Array(n));if("bool"===t)return q(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function L(e){e.forEach((t=>{c(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function j(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function H(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function X(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{AE:()=>y,Cq:()=>p,D2:()=>G,D5:()=>T,E7:()=>h,EC:()=>k,GN:()=>b,GX:()=>q,HD:()=>B,JZ:()=>S,KS:()=>z,LF:()=>o,LP:()=>I,Mu:()=>L,NA:()=>f,NE:()=>H,QB:()=>N,Sm:()=>l,TV:()=>r,U$:()=>v,Ub:()=>V,WD:()=>$,WP:()=>E,YP:()=>w,bT:()=>M,bj:()=>u,bp:()=>x,cO:()=>g,d7:()=>s,e3:()=>W,hj:()=>D,hu:()=>c,jP:()=>P,jn:()=>R,k5:()=>d,l6:()=>U,mf:()=>C,nY:()=>i,oj:()=>_,p8:()=>F,qy:()=>j,rQ:()=>A,tI:()=>X,uZ:()=>a,wT:()=>K,xH:()=>m})}}]);